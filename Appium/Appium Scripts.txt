//Running Tests on IOS
1)Basically, first make sure Appium is running:
node .
2)Then script your WebDriver test, sending in the following desired capabilities:

//java
DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(MobileCapabilityType.PLATFORM_NAME, "iOS");
capabilities.setCapability(MobileCapabilityType.PLATFORM_VERSION, "7.1");
capabilities.setCapability(MobileCapabilityType.DEVICE_NAME, "iPhone Simulator");
capabilities.setCapability(MobileCapabilityType.APP, myApp);

//PYTHON
{
    'platformName': 'iOS',
    'platformVersion': '7.1',
    'deviceName': 'iPhone Simulator',
    'app': myApp
}

3)JS
{
    platformName: 'iOS',
    platformVersion: '7.1',
    deviceName: 'iPhone Simulator',
    app: myApp
}
n this set of capabilities, myApp must be either:

A local absolute path to your simulator-compiled .app directory or .zip
A url of a zip file containing your .app package
A path to one of the sample app relative to the appium install root

1)Running your test app with Appium (Android)
First, make sure you have one and only one Android emulator or device connected.
 If you run adb devices, for example, you should see one device connected. 
 This is the device Appium will use for tests. Of course, to have a device connected, you'll need to have made an Android AVD.
  If the Android SDK tools are on your path, you can simply run:

2)  emulator -avd <MyAvdName>

And wait for the android emulator to finish launching. Sometimes, for various reasons, adb gets stuck. 
If it's not showing any connected devices or otherwise failing, you can restart it by running:

  adb kill-server && adb devices

Now, make sure Appium is running:

3)  node .

 Then script your WebDriver test, sending in the following desired capabilities: 

4)//java
DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(MobileCapabilityType.PLATFORM_NAME, "Android");
capabilities.setCapability(MobileCapabilityType.PLATFORM_VERSION, "4.4");
capabilities.setCapability(MobileCapabilityType.DEVICE_NAME, "Android Emulator");
capabilities.setCapability(MobileCapabilityType.APP, myApp);

//PYTHON
{
    'platformName': 'Android',
    'platformVersion': '4.4',
    'deviceName': 'Android Emulator',
    'app': myApp
}

//JS
{
    platformName: 'Android',
    platformVersion: '4.4',
    deviceName: 'Android Emulator',
    app: myApp
}

/////////////////////////////////////////////


   //Desired Copabilities Example
{
    "platformName": "iOS",
    "platformVersion": "11.0",
    "deviceName": "iPhone 7",
    "automationName": "XCUITest",
    "app": "/path/to/my.app"
}

FULL LIST OF Copabilities:
https://appium.io/docs/en/writing-running-appium/caps/


# raw JSON as an argument
--default-capabilities '{"app": "myapp.app", "deviceName": "iPhone Simulator"}'
# or the name of a JSON file
--default-capabilities /path/to/file.json

//Pseudocode example of tapping with two fingers:

action0 = TouchAction().tap(el)
action1 = TouchAction().tap(el)
MultiAction().add(action0).add(action1).perform()

Automating Sliders

iOS

Java
// java
// slider values can be string representations of numbers between 0 and 1
// e.g., "0.1" is 10%, "1.0" is 100%
WebElement slider =  driver.findElement(By.xpath("//window[1]/slider[1]"));
slider.sendKeys("0.1");

///////////////////////////////////Image Comparison Example//////////////////////////////

// java

byte[] screenshot = Base64.encodeBase64(driver.getScreenshotAs(OutputType.BYTES));
FeaturesMatchingResult result = driver
        .matchImagesFeatures(screenshot, originalImg, new FeaturesMatchingOptions()
                .withDetectorName(FeatureDetector.ORB)
                .withGoodMatchesFactor(40)
                .withMatchFunc(MatchingFunction.BRUTE_FORCE_HAMMING)
                .withEnabledVisualization());
assertThat(result.getVisualization().length, is(greaterThan(0)));
assertThat(result.getCount(), is(greaterThan(0)));
assertThat(result.getTotalCount(), is(greaterThan(0)));
assertFalse(result.getPoints1().isEmpty());
assertNotNull(result.getRect1());
assertFalse(result.getPoints2().isEmpty());
assertNotNull(result.getRect2());

# Ruby
image1 = File.read 'first/image/path.png'
image2 = File.read 'second/image/path.png'

match_result = @driver.match_images_features first_image: image1, second_image: image2
assert_equal %w(points1 rect1 points2 rect2 totalCount count), match_result.keys

match_result_visual = @driver.match_images_features first_image: image1, second_image: image2, visualize: true
assert_equal %w(points1 rect1 points2 rect2 totalCount count visualization), match_result_visual.keys
File.open('match_result_visual.png', 'wb') { |f| f<< Base64.decode64(match_result_visual['visualization']) }
assert File.size? 'match_result_visual.png'

//////////////////////////////////Image Occurrences Lookup Examples////////////////////////////////

// java

byte[] screenshot = Base64.encodeBase64(driver.getScreenshotAs(OutputType.BYTES));
OccurrenceMatchingResult result = driver
        .findImageOccurrence(screenshot, partialImage, new OccurrenceMatchingOptions()
                .withEnabledVisualization());
assertThat(result.getVisualization().length, is(greaterThan(0)));
assertNotNull(result.getRect());

// Typescript / Javascript
  /*
     Typescsript code for occurrence comparison using the template matching algorithm.
     It detects if an image is contained in another image (called the template).
     The image must have the same scale and look the same. However, you can add a scaling transformation beforehand.

     official doc:
     https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/image-comparison.md
     OpenCV algorithm doc:
     https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html
     official sample code:
     https://github.com/justadudewhohacks/opencv4nodejs/blob/master/examples/templateMatching.js

     You must install opencv4nodejs using the -g option.

     The Javascript client driver webdriverio does not support (in January 2020) the "-image" strategy implemented in the Appium server. You will have more power and understanding while using openCV directly. Since the appium server is in Javascript, you can do all it does with opencv in your test suite.

     The testing framework mocha can be run with typescript to have async/await.
     You need to run mocha with those options in the right order and with the associated packages installed:
     NODE_PATH=/path/to/nodejs/lig/node_modules TS_NODE_PROJECT=config/tsconfig_test.json --require ts-node/register --require tsconfig-paths/register
     You will also need to make a basic config/tsconfig_test.json
     Note that paths in tsconfig.json does not support absolute paths. Hence, you cannot move the NODE_PATH there.
  */
  import * as path from 'path';
  const cv = require(path.join(process.env.NODE_PATH, 'opencv4nodejs'));
  const isImagePresent = async () => {
    /// Take screenshot and read the image
    const screenImagePath = './appium_screenshot1.png';
    await driver.saveScreenshot(screenImagePath)
    const likedImagePath = './occurrence1.png';

    // Load images
    const originalMatPromise = cv.imreadAsync(screenImagePath);
    const waldoMatPromise = cv.imreadAsync(likedImagePath);
    const [originalMat, waldoMat] = await Promise.all([originalMatPromise, waldoMatPromise]);

    // Match template (the brightest locations indicate the highest match)
    // In the OpenCV doc, the option 5 refers to the algorithm called CV_TM_CCOEFF_NORMED
    const matched = originalMat.matchTemplate(waldoMat, 5);

    // Use minMaxLoc to locate the highest value (or lower, depending of the type of matching method)
    const minMax = matched.minMaxLoc();
    const { maxLoc: { x, y } } = minMax;

    // Draw bounding rectangle
    originalMat.drawRectangle(
      new cv.Rect(x, y, waldoMat.cols, waldoMat.rows),
      new cv.Vec(0, 255, 0),
      2,
      cv.LINE_8
    );

    // Open result in new window
    // If the image is too big for your screen, you need to write to a file instead.
    // Check the source of opencv4nodejs for writing an image to a file.
    cv.imshow('We\'ve found Waldo!', originalMat);
    await cv.waitKey();

    // then you know if the image was found by comparing the rectangle with a reference rectangle.
    // the structure minMax contains the property maxVal that gives the quality of the match
    // 1 is prefect match, but you may get .999. If you extract an image from the screenshot manually,
    // you will get an image that matches.
  };

//Ruby
image1 = File.read 'first/image/path.png'
image2 = File.read 'partial/image/path.png'

find_result = @driver.find_image_occurrence full_image: image1, partial_image: image2
assert_equal({ 'rect' => { 'x' => 0, 'y' => 0, 'width' => 750, 'height' => 1334 } }, find_result)

find_result_visual = @driver.find_image_occurrence full_image: image1, partial_image: image2, visualize: true
assert_equal %w(rect visualization), find_result_visual.keys
File.open('find_result_visual.png', 'wb') { |f| f<< Base64.decode64(find_result_visual['visualization']) }
assert File.size? 'find_result_visual.png'

////////////////////////////////////Image Similarity Calculation////////////////////////////////////

Examples
// java

byte[] screenshot1 = Base64.encodeBase64(driver.getScreenshotAs(OutputType.BYTES));
byte[] screenshot2 = Base64.encodeBase64(driver.getScreenshotAs(OutputType.BYTES));
SimilarityMatchingResult result = driver
        .getImagesSimilarity(screenshot1, screenshot2, new SimilarityMatchingOptions()
                .withEnabledVisualization());
assertThat(result.getVisualization().length, is(greaterThan(0)));
assertThat(result.getScore(), is(greaterThan(0.0)));

//All the SimilarityMatchingOptions builder methods above contain detailed descriptions in their docstrings.

# Ruby
image1 = File.read 'first/image/path.png'
image2 = File.read 'second/image/path.png'

get_images_result = @driver.get_images_similarity first_image: image1, second_image: image2
assert_equal({ 'score' => 0.891606867313385 }, get_images_result)

get_images_result_visual = @driver.get_images_similarity first_image: image1, second_image: image2, visualize: true
assert_equal %w(score visualization), get_images_result_visual.keys
File.open('get_images_result_visual.png', 'wb') { |f| f<< Base64.decode64(get_images_result_visual['visualization']) }
assert File.size? 'get_images_result_visual.png'

///////////////////////////////////////////////////////IOS Tests Automation/////////////////////////////////////////////////////////
Use desired capabilities like these to run your test in mobile Safari:

//Java
DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(MobileCapabilityType.PLATFORM_NAME, "iOS");
capabilities.setCapability(MobileCapabilityType.PLATFORM_VERSION, "13.2");
capabilities.setCapability(MobileCapabilityType.AUTOMATION_NAME, "XCUITest");
capabilities.setCapability(MobileCapabilityType.BROWSER_NAME, "Safari");
capabilities.setCapability(MobileCapabilityType.DEVICE_NAME, "iPhone 11");
 
//PYTHON
{
  'platformName': 'iOS',
  'platformVersion': '13.2',
  'automationName': 'XCUITest',
  'browserName': 'Safari',
  'deviceName': 'iPhone 11'
}
//JS
{
  platformName: 'iOS'
  , platformVersion: '13.2'
  , automationName: 'XCUITest'
  , browserName: 'Safari'
  , deviceName: 'iPhone 11'
}
//Ruby
{
  platformName: 'iOS',
  platformVersion: '13.2',
  automationName: 'XCUITest',
  deviceName: 'iPhone 11',
  browserName: 'Safari'
}

Running your test
To configure you test to run against safari simply set the "browserName" to be "Safari".

////Java

# setup the web driver and launch the webview app.
capabilities = { 'browserName': 'Safari', 'automationName': 'XCUITest' }
driver = webdriver.Remote('http://localhost:4723/wd/hub', capabilities)

# Navigate to the page and interact with the elements on the guinea-pig page using id.
driver.get('http://saucelabs.com/test/guinea-pig');
div = driver.find_element_by_id('i_am_an_id')
# check the text retrieved matches expected value
assertEqual('I am a div', div.text)

# populate the comments field by id
driver.find_element_by_id('comments').send_keys('My comment')

# close the driver
driver.quit()

////Python
# setup the web driver and launch the webview app.
capabilities = { 'browserName': 'Safari', 'automationName': 'XCUITest' }
driver = webdriver.Remote('http://localhost:4723/wd/hub', capabilities)

# Navigate to the page and interact with the elements on the guinea-pig page using id.
driver.get('http://saucelabs.com/test/guinea-pig');
div = driver.find_element_by_id('i_am_an_id')
# check the text retrieved matches expected value
assertEqual('I am a div', div.text)

# populate the comments field by id
driver.find_element_by_id('comments').send_keys('My comment')

# close the driver
driver.quit()

///////////////////////////////////////////////////////////Android mobile web automation///////////////////////////////////

Capabilities:
//Java
DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setCapability(MobileCapabilityType.PLATFORM_NAME, "Android");
capabilities.setCapability(MobileCapabilityType.PLATFORM_VERSION, "9.0");
capabilities.setCapability(MobileCapabilityType.DEVICE_NAME, "Android Emulator");
capabilities.setCapability(MobileCapabilityType.AUTOMATION_NAME, "UIAutomator2");
capabilities.setCapability(MobileCapabilityType.BROWSER_NAME, "Chrome");



//JS
{
  platformName: 'Android'
  , platformVersion: '9.0'
  , deviceName: 'Android Emulator'
  , automationName: 'UIAutomator2'
  , browserName: 'Chrome'
};

//RUBY
{
  platformName: 'Android',
  platformVersion: '9.0',
  deviceName: 'Android Emulator',
  automationName: 'UIAutomator2',
  browserName: 'Chrome'
}

//Python
{
  'platformName': 'Android',
  'platformVersion': '9.0',
  'deviceName': 'Android Emulator',
  'automationName': 'UIAutomator2',
  'browserName': 'Chrome'
}


////Automatically entering the web view context on session start///

//Java
// assuming we have a set of capabilities
driver = new AppiumDriver(new URL("http://127.0.0.1:4723/wd/hub"), capabilities);

Set<String> contextNames = driver.getContextHandles();
for (String contextName : contextNames) {
    System.out.println(contextName); //prints out something like NATIVE_APP \n WEBVIEW_1
}
driver.context(contextNames.toArray()[1]); // set context to WEBVIEW_1

//do some web testing
String myText = driver.findElement(By.cssSelector(".green_button")).click();

driver.context("NATIVE_APP");

// do more native testing if we want

driver.quit();

//Python

# assuming we have an initialized `driver` object for an app

# switch to webview
webview = driver.contexts.last
driver.switch_to.context(webview)

# do some webby stuff
driver.find_element(By.CSS, ".green_button").click

# switch back to native view
driver.switch_to.context(driver.contexts.first)

# do more native testing if we want

driver.quit()

//JS

// assuming we have an initialized `driver` object for an app
driver
    .contexts().then(function (contexts) { // get list of available views. Returns array: ["NATIVE_APP","WEBVIEW_1"]
        return driver.context(contexts[1]); // choose the webview context
    })

    // do some web testing
    .elementsByCss('.green_button').click()

    .context('NATIVE_APP') // leave webview context

    // do more native stuff here if we want

    .quit() // stop webdrivage

//Ruby
# assuming we have a set of capabilities
@driver = Appium::Core.for(url: SERVER_URL, desired_capabilities: capabilities).start_driver
# ruby_lib
# opts = { caps: capabilities, appium_lib: { custom_url: SERVER_URL }}
# @driver = Appium::Driver.new(opts, true).start_driver

# I switch to the last context because its always the webview in our case, in other cases you may need to specify a context
# View the appium logs while running @driver.contexts to figure out which context is the one you want and find the associated ID
# Then switch to it using @driver.switch_to.context("WEBVIEW_6")

Given(/^I switch to webview$/) do
    webview = @driver.available_contexts.last
    @driver.switch_to.context(webview)
end

Given(/^I switch out of webview$/) do
    @driver.switch_to.context(@driver.contexts.first)
end

# Now you can use CSS to select an element inside your webview

And(/^I click a webview button $/) do
    @driver.find_element(:css, ".green_button").click
end

//IOS Predicate
# Ruby example
text = 'Various uses'
predicate = "name contains[c] '#{text}' || label contains[c] '#{text}' || value contains[c] '#{text}'"
element = execute_script(%Q(au.mainApp().getFirstWithPredicate("#{predicate}");))

puts element.name # Buttons, Various uses of UIButton

////////////////////////////////Android uiautomator UiSelector///////////////////////////
Find the first textview.

# ruby
first_textview = find_element(:uiautomator, 'new UiSelector().className("android.widget.TextView").instance(0)');

# ruby
first_text = find_element(:uiautomator, 'new UiSelector().text("Animation")')
first_text.text # "Animation"

Find the first scrollable element, then find a TextView with the text "Tabs". The "Tabs" element will be scrolled into view.

# ruby
element = find_element(:uiautomator, 'new UiScrollable(new UiSelector().scrollable(true).instance(0)).getChildByText(new UiSelector().className("android.widget.TextView"), "Tabs")')

As a special case, scrollIntoView returns the element that is scrolled into view. scrollIntoView allows scrolling to any UiSelector.

# ruby
element = find_element(:uiautomator, 'new UiScrollable(new UiSelector().scrollable(true).instance(0)).scrollIntoView(new UiSelector().text("WebView").instance(0));')
element.text # "WebView"

/////////////Example//////////////
This is a ListView taken from the source XML of an Android App:

<android.widget.ListView index="0" package="io.appium.android.apis" class="android.widget.ListView" checkable="false" checked="false" clickable="true" enabled="true" focusable="true" focused="false" scrollable="true" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,210][1080,1794]" resource-id="android:id/list" adapter-type="HashMap" adapters="{contentDescription=Animation, title=Animation, intent=Intent { cmp=io.appium.android.apis/.ApiDemos (has extras) }},{contentDescription=Auto Complete, title=Auto Complete, intent=Intent { cmp=io.appium.android.apis/.ApiDemos (has extras) }}, ...}">
    <android.widget.TextView index="0" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Drag and Drop" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,148][1080,274]" text="Drag and Drop" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="1" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Expandable Lists" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,277][1080,403]" text="Expandable Lists" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="2" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Focus" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,406][1080,532]" text="Focus" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="3" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Gallery" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,535][1080,661]" text="Gallery" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="4" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Game Controller Input" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,664][1080,790]" text="Game Controller Input" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="5" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Grid" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,793][1080,919]" text="Grid" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="6" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Hover Events" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,922][1080,1048]" text="Hover Events" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="7" package="io.appium.android.apis" class="android.widget.TextView" content-desc="ImageButton" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,1051][1080,1177]" text="ImageButton" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="8" package="io.appium.android.apis" class="android.widget.TextView" content-desc="ImageSwitcher" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,1180][1080,1306]" text="ImageSwitcher" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="9" package="io.appium.android.apis" class="android.widget.TextView" content-desc="ImageView" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,1309][1080,1435]" text="ImageView" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="10" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Layout Animation" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,1438][1080,1564]" text="Layout Animation" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="11" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Layouts" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,1567][1080,1693]" text="Layouts" hint="false" resource-id="android:id/text1" />
    <android.widget.TextView index="12" package="io.appium.android.apis" class="android.widget.TextView" content-desc="Lists" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible="true" bounds="[0,1696][1080,1822]" text="Lists" hint="false" resource-id="android:id/text1" />
</android.widget.ListView>

The ListView node in the above XML has an attribute called adapters that contains the data that "backs up" the ListView:

{
    contentDescription = Animation, title = Animation, intent = Intent {
        cmp = io.appium.android.apis / .ApiDemos(has extras)
    }
}, {
    contentDescription = Auto Complete,
    title = Auto Complete,
    intent = Intent {
        cmp = io.appium.android.apis / .ApiDemos(has extras)
    }
}, {
    contentDescription = Buttons,
    title = Buttons,
    intent = Intent {
        cmp = io.appium.android.apis / .view.Buttons1
    }
},
...

//////These items can be targeted using a datamatcher selector. Here's a code snippet that shows how to locate and click TextClock:

//Javascript example
driver.findElementById("list")
  .findElement("-android datamatcher", JSON.stringify({
    "name": "hasEntry",
    "args": ["title", "TextClock"]
  }))
  .click();

//Python example
  driver.find_element_by_id('list')
    .find_element_by_android_data_matcher({
        name='hasEntry',
        args=['title', 'TextClock']
    })
    .click()

//Ruby example
    @driver.find_element(:id, 'list')
  .find_element(:data_matcher, {
    name: 'hasEntry',
    args: ['title', 'TextClock']
  }.to_json)
  .click

  This Appium selector is equivalent to writing this matcher in Espresso:

  // Espresso code (not Appium code)
  onData(hasEntry("title", "textClock")
    .inAdapterView(withId("android:id/list))
    .perform(click());

    
//Locating the parent AdapterView is not necessary if the Activity only has one adapter view. In that case, it can be omitted.

/Javascrypt example
  driver.findElement("-android datamatcher", JSON.stringify({
      "name": "hasEntry",
      "args": ["title", "TextClock"]
    }))
    .click();
  
//Python Example
driver.find_element_by_android_data_matcher({
  name='hasEntry',
  args=['title', 'TextClock']
}).click()

//Python Example
@driver.find_element(:data_matcher, {
  name: 'hasEntry',
  args: ['title', 'TextClock']
}.to_json).click

//Examples of JSON matchers with the equivalent Espresso onData matcher

//StartsWith
//Js
// 'startsWith' JSON
{
  "name": "startsWith",
  "args": "substr" // if it's a single arg, we don't need args to be an array
}

//Java
// Espresso 'startsWith' example
onData(startsWith("substr"));

//Multiple Matchers
//Js
// 'multiple matchers' JSON
{
  "name": "allOf",
  "args": [
    {"name": "instanceOf", "args": "Map.class"},
    {"name": "hasEntry", "args": {
      "name": "equalTo", "args": "STR"
    }},
    {"name": "is", "args": "item: 50"}
  ]
}

//Java
// Espresso 'multiple matchers' example
onData(allOf(is(instanceOf(Map.class)), hasEntry(equalTo("STR"), is("item: 50"))));
Cursor Matchers
//Js
// 'cursor matchers' JSON
{
  "name": "is", "args": {
    "name": "instanceOf", "args": "Cursor.class"
  },
  "name": "CursorMatchers.withRowString", "args": [
    "job_title", {"name": "is", "args": "Barista"}
  ]
}

//Java
// Espresso 'cursor matchers' example
onData(
    is(instanceOf(Cursor.class)),
    CursorMatchers.withRowString("job_title", is("Barista"))
);


//Shell Commands On The Remote Device
//Java
Map<String, Object> args = new HashMap<>();
args.put("command", "echo");
args.put("args", Lists.newArrayList("arg1", "arg2"));
String output = driver.executeScript("mobile: shell", args);
assert output.equals("arg1 arg2");

//JS
const output = driver.executeScript('mobile: shell', [{
  command: 'ls',
  args: ['/sdcard'],
  }]);
//PYTHON
result = driver.execute_script('mobile: shell', {
  'command': 'echo',
  'args': ['arg1', 'arg2'],
  'includeStderr': True,
  'timeout': 5000
})
assert result['stdout'] == 'arg1 arg2'

// javascript
// set airplane mode
driver.setNetworkConnection(1)

// set wifi only
driver.setNetworkConnection(2)

// set data only
driver.setNetworkConnection(4)

// set wifi and data
driver.setNetworkConnection(6)

// javascript
driver.getNetworkConnection().then(function (connectionType) {
  switch (connectionType) {
    case 0:
      // no network connection
      break;
    case 1:
      // airplane mode
      break;
    case 2:
      // wifi
      break;
    case 4:
      // data
      break;
    case 6:
      // wifi and data
      break;
  }
});

////////////////////////Strings Format Normalization//////////////////
// javascript
var unorm = require('unorm');

'some ASCII text' === unorm.nfd('some ASCII text');
unorm.nfd('Adélaïde Hervé') === unorm.nfd(unorm.nfd('Adélaïde Hervé'));

// javascript
var unorm = require('unorm');
driver
  .elementByAccessibilityId('find')
    .text()
    .then(function (txt) {
      unorm.nfd(txt).should.be(unorm.nfd("é Œ ù ḍ"));
    });

//Finding by text can also require normalization. For instance, if you have a button in an iOS app with the name Найти you may need to normalize the text within the find command.

    // javascript
    var unorm = require('unorm');
    driver
      .findElementByXPath(unorm.nfd("//UIAButton[@name='Найти']"))
        .should.eventually.exist;
//One tell-tale sign that the problem is with the encoding of the unicode text is an assertion that fails but reports what look to be the same string:

        AssertionError: expected 'François Gérard' to deeply equal 'François Gérard'
              + expected - actual
        
              +"François Gérard"
              -"François Gérard"
// As above, the text received may need to be normalized before asserting on it.

// javascript
var unorm = require('unorm');
var testText = unorm.nfd("é Œ ù ḍ");
driver
  .elementsByClassName('UIATextField').at(1)
    .sendKeys(testText)
    .text()
    .should.become(testText)
  .nodeify(done);

//Then tests can pass Unicode text to editable fields using send_keys.

  // javascript
  var desired = {
    app: '/path/to/app',
    deviceName: 'Android Emulator',
    deviceVersion: '4.4',
    platformName: 'Android',
    unicodeKeyboard: true,
    resetKeyboard: true
  };
  var testText = 'é Œ ù ḍ';
  driver
    .elementByClassName('android.widget.EditText')
    .sendKeys(testText)
    .text()
    .should.eventually.become(testText)
    .nodeify(done);
  
  //Images Debug
  # Ruby core
@driver.update_settings({ getMatchedImageResult: true })
el = @driver.find_element_by_image 'path/to/img.ong'
img_el.visual # returns base64 encoded string

self.driver.update_settings({"getMatchedImageResult": True})
el = self.driver.find_element_by_image('path/to/img.ong')
el.get_attribute('visual') # returns base64 encoded string

//Grid Node Configuration Example json file
{
  "capabilities":
      [
        {
          "browserName": "<e.g._iPhone5_or_iPad4>",
          "version":"<version_of_iOS_e.g._7.1>",
          "maxInstances": 1,
          "platform":"<platform_e.g._MAC_or_ANDROID>"
        }
      ],
  "configuration":
  {
    "cleanUpCycle":2000,
    "timeout":30000,
    "proxy": "org.openqa.grid.selenium.proxy.DefaultRemoteProxy",
    "url":"http://<host_name_appium_server_or_ip-address_appium_server>:<appium_port>/wd/hub",
    "host": "<host_name_appium_server_or_ip-address_appium_server>",
    "port": <appium_port>,
    "maxSession": 1,
    "register": true,
    "registerCycle": 5000,
    "hubPort": <grid_port>,
    "hubHost": "<Grid_host_name_or_grid_ip-address>"
    "hubProtocol": "<Protocol_of_Grid_defaults_to_http>"
  }
}

//Logs Filtering
Config Examples
Replace all occurrences of my.magic.app string with the default replacer:

[
    {
        "text": "my.magic.app"
    }
]
Replace all occurrences of my.magic.<any char> string with a custom replacer (case insensitive):

[
    {
        "pattern": "my\\.magic\\.\\w",
        "flags": "i",
        "replacer": "***"
    }
]
Replace all occurrences of my.magic.<any chars> and/or your.magic strings with a custom replacer (case insensitive):

[
    {
        "pattern": "my\\.magic\\.\\w+",
        "flags": "i",
        "replacer": "***"
    },
    {
        "pattern": "your\\.magic",
        "flags": "i",
        "replacer": "***"
    }
]
Cut off all log lines to max 15 chars (advanced):

[
    {
        "pattern": "(.{1,15}).*",
        "flags": "s",
        "replacer": "$1"
    }
]

//Cross-domain iFrame Automation
Parent:

<html>
  <head>
    <script>
      document.domain = 'site.com';
    </script>
  </head>
  <body>
    <iframe src="http://shop.site.com" width="200" height="200"></iframe>
  </body>
</html>
Child iFrame:

<html>
  <head>
    <script>
      document.domain = 'site.com';
    </script>
  </head>
  <body>
    <p>This is an iFrame!</p>
  </body>
</html>

//How To Set Up And Customize WebDriverAgent Server
//This helper class written in Java illustrates the main implementation details wit iproxy:
public class WDAServer {
  private static final Logger log = ZLogger.getLog(WDAServer.class.getSimpleName());

  private static final int MAX_REAL_DEVICE_RESTART_RETRIES = 1;
  private static final Timedelta REAL_DEVICE_RUNNING_TIMEOUT = Timedelta.ofMinutes(4);
  private static final Timedelta RESTART_TIMEOUT = Timedelta.ofMinutes(1);

  // These settings are needed to properly sign WDA for real device tests
  // See https://github.com/appium/appium-xcuitest-driver for more details
  private static final File KEYCHAIN = new File(String.format("%s/%s",
          System.getProperty("user.home"), "/Library/Keychains/MyKeychain.keychain"));
  private static final String KEYCHAIN_PASSWORD = "******";

  private static final File IPROXY_EXECUTABLE = new File("/usr/local/bin/iproxy");
  private static final File XCODEBUILD_EXECUTABLE = new File("/usr/bin/xcodebuild");
  private static final File WDA_PROJECT =
          new File("/usr/local/lib/node_modules/appium/node_modules/appium-webdriveragent" +
                  "/WebDriverAgent.xcodeproj");
  private static final String WDA_SCHEME = "WebDriverAgentRunner";
  private static final String WDA_CONFIGURATION = "Debug";
  private static final File XCODEBUILD_LOG = new File("/usr/local/var/log/appium/build.log");
  private static final File IPROXY_LOG = new File("/usr/local/var/log/appium/iproxy.log");

  private static final int PORT = 8100;
  public static final String SERVER_URL = String.format("http://127.0.0.1:%d", PORT);

  private static final String[] IPROXY_CMDLINE = new String[]{
          IPROXY_EXECUTABLE.getAbsolutePath(),
          Integer.toString(PORT),
          Integer.toString(PORT),
          String.format("> %s 2>&1 &", IPROXY_LOG.getAbsolutePath())
  };

  private static WDAServer instance = null;
  private final boolean isRealDevice;
  private final String deviceId;
  private final String platformVersion;
  private int failedRestartRetriesCount = 0;

  private WDAServer() {
      try {
          this.isRealDevice = !getIsSimulatorFromConfig(getClass());
          final String udid;
          if (isRealDevice) {
              udid = IOSRealDeviceHelpers.getUDID();
          } else {
              udid = IOSSimulatorHelpers.getId();
          }
          this.deviceId = udid;
          this.platformVersion = getPlatformVersionFromConfig(getClass());
      } catch (Exception e) {
          throw new RuntimeException(e);
      }
      ensureToolsExistence();
      ensureParentDirExistence();
  }

  public synchronized static WDAServer getInstance() {
      if (instance == null) {
          instance = new WDAServer();
      }
      return instance;
  }

  private boolean waitUntilIsRunning(Timedelta timeout) throws Exception {
      final URL status = new URL(SERVER_URL + "/status");
      try {
          if (timeout.asSeconds() > 5) {
              log.debug(String.format("Waiting max %s until WDA server starts responding...", timeout));
          }
          new UrlChecker().waitUntilAvailable(timeout.asMillis(), TimeUnit.MILLISECONDS, status);
          return true;
      } catch (UrlChecker.TimeoutException e) {
          return false;
      }
  }

  private static void ensureParentDirExistence() {
      if (!XCODEBUILD_LOG.getParentFile().exists()) {
          if (!XCODEBUILD_LOG.getParentFile().mkdirs()) {
              throw new IllegalStateException(String.format(
                      "The script has failed to create '%s' folder for Appium logs. " +
                              "Please make sure your account has correct access permissions on the parent folder(s)",
                      XCODEBUILD_LOG.getParentFile().getAbsolutePath()));
          }
      }
  }

  private void ensureToolsExistence() {
      if (isRealDevice && !IPROXY_EXECUTABLE.exists()) {
          throw new IllegalStateException(String.format("%s tool is expected to be installed (`npm install -g iproxy`)",
                  IPROXY_EXECUTABLE.getAbsolutePath()));
      }
      if (!XCODEBUILD_EXECUTABLE.exists()) {
          throw new IllegalStateException(String.format("xcodebuild tool is not detected on the current system at %s",
                  XCODEBUILD_EXECUTABLE.getAbsolutePath()));
      }
      if (!WDA_PROJECT.exists()) {
          throw new IllegalStateException(String.format("WDA project is expected to exist at %s",
                  WDA_PROJECT.getAbsolutePath()));
      }
  }

  private List<String> generateXcodebuildCmdline() {
      final List<String> result = new ArrayList<>();
      result.add(XCODEBUILD_EXECUTABLE.getAbsolutePath());
      result.add("clean build test");
      result.add(String.format("-project %s", WDA_PROJECT.getAbsolutePath()));
      result.add(String.format("-scheme %s", WDA_SCHEME));
      result.add(String.format("-destination id=%s", deviceId));
      result.add(String.format("-configuration %s", WDA_CONFIGURATION));
      result.add(String.format("IPHONEOS_DEPLOYMENT_TARGET=%s", platformVersion));
      result.add(String.format("> %s 2>&1 &", XCODEBUILD_LOG.getAbsolutePath()));
      return result;
  }

  private static List<String> generateKeychainUnlockCmdlines() throws Exception {
      final List<String> result = new ArrayList<>();
      result.add(String.format("/usr/bin/security -v list-keychains -s %s", KEYCHAIN.getAbsolutePath()));
      result.add(String.format("/usr/bin/security -v unlock-keychain -p %s %s",
              KEYCHAIN_PASSWORD, KEYCHAIN.getAbsolutePath()));
      result.add(String.format("/usr/bin/security set-keychain-settings -t 3600 %s", KEYCHAIN.getAbsolutePath()));
      return result;
  }

  public synchronized void restart() throws Exception {
      if (isRealDevice && failedRestartRetriesCount >= MAX_REAL_DEVICE_RESTART_RETRIES) {
          throw new IllegalStateException(String.format(
                  "WDA server cannot start on the connected device with udid %s after %s retries. " +
                          "Reboot the device manually and try again", deviceId, MAX_REAL_DEVICE_RESTART_RETRIES));
      }

      final String hostname = InetAddress.getLocalHost().getHostName();
      log.info(String.format("Trying to (re)start WDA server on %s:%s...", hostname, PORT));
      UnixProcessHelpers.killProcessesGracefully(IPROXY_EXECUTABLE.getName(), XCODEBUILD_EXECUTABLE.getName());

      final File scriptFile = File.createTempFile("script", ".sh");
      try {
          final List<String> scriptContent = new ArrayList<>();
          scriptContent.add("#!/bin/bash");
          if (isRealDevice && isRunningInJenkinsNetwork()) {
              scriptContent.add(String.join("\n", generateKeychainUnlockCmdlines()));
          }
          if (isRealDevice) {
              scriptContent.add(String.join(" ", IPROXY_CMDLINE));
          }
          final String wdaBuildCmdline = String.join(" ", generateXcodebuildCmdline());
          log.debug(String.format("Building WDA with command line:\n%s\n", wdaBuildCmdline));
          scriptContent.add(wdaBuildCmdline);
          try (Writer output = new BufferedWriter(new FileWriter(scriptFile))) {
              output.write(String.join("\n", scriptContent));
          }
          new ProcessBuilder("/bin/chmod", "u+x", scriptFile.getCanonicalPath())
                  .redirectErrorStream(true).start().waitFor(5, TimeUnit.SECONDS);
          final ProcessBuilder pb = new ProcessBuilder("/bin/bash", scriptFile.getCanonicalPath());
          final Map<String, String> env = pb.environment();
          // This is needed for Jenkins
          env.put("BUILD_ID", "dontKillMe");
          // This line is important. If USE_PORT environment variable is not set then WDA
          // takes port number zero by default and won't accept any incoming requests
          env.put("USE_PORT", Integer.toString(PORT));
          log.info(String.format("Waiting max %s for WDA to be (re)started on %s:%s...", RESTART_TIMEOUT.toString(),
                  hostname, PORT));
          final Timedelta started = Timedelta.now();
          pb.redirectErrorStream(true).start().waitFor(RESTART_TIMEOUT.asMillis(), TimeUnit.MILLISECONDS);
          if (!waitUntilIsRunning(RESTART_TIMEOUT)) {
              ++failedRestartRetriesCount;
              throw new IllegalStateException(
                      String.format("WDA server has failed to start after %s timeout on server '%s'.\n"
                                      + "Please make sure that iDevice is properly connected and you can build "
                                      + "WDA manually from XCode.\n"
                                      + "Xcodebuild logs:\n\n%s\n\n\niproxy logs:\n\n%s\n\n\n",
                              RESTART_TIMEOUT, hostname,
                              getLog(XCODEBUILD_LOG).orElse("EMPTY"), getLog(IPROXY_LOG).orElse("EMPTY"))
              );
          }

          log.info(String.format("WDA server has been successfully (re)started after %s " +
                  "and now is listening on %s:%s", Timedelta.now().diff(started).toString(), hostname, PORT));
      } finally {
          scriptFile.delete();
      }
  }

  public boolean isRunning() throws Exception {
      if (!isProcessRunning(XCODEBUILD_EXECUTABLE.getName())
              || (isRealDevice && !isProcessRunning(IPROXY_EXECUTABLE.getName()))) {
          return false;
      }
      return waitUntilIsRunning(isRealDevice ? REAL_DEVICE_RUNNING_TIMEOUT : Timedelta.ofSeconds(3));
  }

  public Optional<String> getLog(File logFile) {
      if (logFile.exists()) {
          try {
              return Optional.of(new String(Files.readAllBytes(logFile.toPath()), Charset.forName("UTF-8")));
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
      return Optional.empty();
  }
}

//One should call this piece of code before to start Appium iOS driver, for example, in setUp method:

   if (!WDAServer.getInstance().isRunning()) {
       WDAServer.getInstance().restart();
   }

//It is important to set webDriverAgentUrl capability for Appium driver to let it know that our WDA driver is ready for use:

    capabilities.setCapability("webDriverAgentUrl", WDAServer.SERVER_URL);

  //Appium Event Timing
  {
    "<event_type>": [<occurence_timestamp_1>, ...],
    "commands": [
        {
            "cmd": "<command_name>",
            "startTime": <js_timestamp>,
            "endTime": <js_timestamp>
        },
        ...
    ]
}

//Update Device Settings
POST /session/:sessionId/appium/settings

//Expects a JSON hash of settings, where keys correspond to setting names, and values to the value of the setting.

{
  settings: {
   ignoreUnimportantViews : true
  }
}

//Retrieve Device Settings
GET /session/:sessionId/appium/settings

//Returns a JSON hash of all the currently specified settings.

{
  ignoreUnimportantViews : true
}

//Memory Collection
Creating a dump file
To create a dump file at any given time, add the following command line parameter to node process, which executes the appium.js script:

--heapsnapshot-signal=&lt;signal&gt;
//where signal can be one of available custom signals, for example SIGUSR2. Then you will be able to

kill -SIGUSR2 &lt;nodePID&gt;

Dump files are created in the same folder where the main Appium script has been executed. They have the .heapsnapshot extension, and can be loaded into the Chrome Inspector for further investigation.

Examples
# 1. Go to the directory where appium is installed via NPM using one of the two cd command below, depending on appium 
# is installed globally or locally
## if your appium is globally installed via NPM with command "npm install -g appium":
cd "$(npm -g root)/appium/"
## else if your appium is locally installed via NPM:
cd "$(npm root)/appium/"

# 2. Start appium server with heapsnapshot signal
# "&" at the end puts the process at background, so we can continue working on the same terminal
node --heapsnapshot-signal=SIGUSR2 . &

# 3. Get the PID of previous node process
pid=$!

# 4. When it's time to dump the heap, issue a SIGUSR2 signal to the PID got above
kill -SIGUSR2 $pid
# Then the heap dump file is created in current directory


  
